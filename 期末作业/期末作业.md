## 使用KLEE生成高代码覆盖率的测试用例
### 符号执行概述
- 符号执行起初应用于基于源代码的安全检测中，它通过符号表达式来模拟程序的执行，将程序的输出表示成包含这些符号的逻辑或数学表达式，从而进行语义分析。
- 符号执行是一种重要的形式化方法和静态分析技术。首先来看一下符号执行中的一些基本概念。程序的路径是程序的一个语句序列，这个语句序列包括程序的一些顺序代码片段，代码片段之间的连接是由于分支语句导致的控制转移。一个路径是可行的，是指存在程序输入变量的至少一组值，如果这组值作为输入，程序将沿着这条路径执行。否则，路径就是不可执行的。路径条件是针对一个路径的，它是一个关于程序输入变量的符号值的约束，一组输入值使得程序沿着这条路执行当且仅当这组输入值满足这条路径的路径条件。
- 符号执行具有代价小、效率高的有点，但缺点也是很明显的。比如路径状态空间的爆炸问题，由于每一个条件分支语句都可能会使当前路径再分出一条新的路径，特别是遇到循环分支时，每增加一次循环都将增加一条新路径，因此这种增长是指数级的。在实践中，通常采用一些这种的办法来解决路径爆炸问题，比如规定每个过程内的分析路径的数目上限，或者设置时间上限和内存上限等来进行缓解
### 符号执行系统结构图
![image](https://raw.githubusercontent.com/PWHL/Software-system-and-security/job1/img3/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%84%E5%9B%BE.png)

### 实验内容
- 利用klee工具对一个目标函数进行符号执行，覆盖全部路径，并且生成测试用例。
- 利用符号执行对程序进行漏洞分析

### 利用klee工具对一个目标函数进行符号执行，覆盖全部路径，并且生成测试用例。

#### 实验环境
- ubuntu16.04
- 使用docker安装klee
```bash
sudo apt install docker.io
sudo docker pull klee/klee
cd klee
docker build -t klee/klee .

# 运行klee镜像
docker run --rm -ti --ulimit='stack=-1:-1' klee/klee
```
### 实验步骤
- 选取目标函数

![image](https://raw.githubusercontent.com/PWHL/Software-system-and-security/job1/img3/fun1.png)
- 对目标函数进行插装
  - klee_make_symbolic函数是将某一个变量符号化，需要三个参数：符号变量地址，符号变量占用内存字节和符号名称
  
![image](https://raw.githubusercontent.com/PWHL/Software-system-and-security/job1/img3/fun2.png)
- 将```get_sign.c```编译成LLVM语言，得到```get_sign.bc```文件。
```
 clang -I ../../include -emit-llvm -c -g get_sign.c
```
- 使用klee进行符号执行```klee get_sign.bc```，生成一个klee执行后的信息统计文件，可以看到klee-last中生成了3个后缀名为```.ktest```的文件

![image](https://raw.githubusercontent.com/PWHL/Software-system-and-security/job1/img3/fun3.png)
![image](https://raw.githubusercontent.com/PWHL/Software-system-and-security/job1/img3/fun4.png)

- 查看生成的用例信息
  - get_sign函数，有三条路径。分别是x=0,x>0,x<0，klee对三条路径进行执行，为每条路径生成一个包含具体值的测试用例。
 - test000001.ktest是x大于0时的路径执行得到的结果
```bash
# 查看test000001.ktest
 ktest-tool test000001.ktest
 
ktest file : 'test000001.ktest'
args       : ['get_sign.bc']
num objects: 1
object 0: name: 'a'
object 0: size: 4
object 0: data: b'\x00\x00\x00\x00'
object 0: hex : 0x00000000
object 0: int : 0
object 0: uint: 0
object 0: text: ....
```
- test000002.ktest是x等于0时的路径执行得到的结果
```bash
# 查看test000002.ktest
 ktest-tool test000001.ktest
 
ktest file : 'test000002.ktest'
args       : ['get_sign.bc']
num objects: 1
object 0: name: 'a'
object 0: size: 4
object 0: data: b'\x01\x01\x01\x01'
object 0: hex : 0x01010101
object 0: int : 16843009
object 0: uint: 16843009
object 0: text: ....
```
- test000003.ktest是x小于0时的路径执行得到的结果
```bash
# 查看test000003.ktest
 ktest-tool test000001.ktest
 
ktest file : 'test000003.ktest'
args       : ['get_sign.bc']
num objects: 1
object 0: name: 'a'
object 0: size: 4
object 0: data: b'\x00\x00\x00\x80'
object 0: hex : 0x00000080
object 0: int : -2147483648
object 0: uint: 2147483648
object 0: text: ....
```
### 利用符号执行对程序进行漏洞分析
- 使用符号执行技术进行漏洞分析，利用符号执行对程序进行漏洞分析。漏洞分析分析的过程主要包括符号执行和约束求解两个部分，并交替执行。通过使用符号执行，将变量的取值表示为符号和常量的计算表达式，将路径条件和程序存在漏洞的条件表示为符号取值的约束。约束求解过程一方面判断路径条件是否可满足，根据判断结果对分析的路径进行取舍，另一方面检查程序存在漏洞的条件是否可以满足。符号执行的过程常常需要利用一定的漏洞分析规则，这些规则描述了在什么情况下需要引入符号，以及在什么情况下程序可能存在漏洞等信息。
- [待分析程序](https://github.com/PWHL/Software-system-and-security/blob/job1/%E6%9C%9F%E6%9C%AB%E4%BD%9C%E4%B8%9A/test.cpp)
### 待完成

### 参考
- [ubuntu安装klee](https://www.twblogs.net/a/5c4ad1acbd9eee6e7d81c673/zh-cn)
- [符号执行](https://github.com/firmianay/CTF-All-In-One/blob/master/doc/5.3_symbolic_execution.md)
